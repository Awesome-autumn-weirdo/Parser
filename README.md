# Parser

### Вариант задания  
Вариант 27

Для грамматики G[(For)] разработать и реализовать алгоритм
анализа на основе метода рекурсивного спуска.

G[(For)]:
1. (For) → for id:=(Operand) to (Operand) do (Stmt) ;
2. (Operand)→ var | const
3. (Stmt)→ var as (ArithExpr)
4. (ArithExpr)→(Operand) {ao (Operand)}

Примечание: for, do, and, or – ключевые слова. В тип ao объединили
арифметические операции + и -, в тип as оператор присваивания =, тип var
– название переменной (только буквы), тип var – числа, тип id -
идентификаторы (буквы и цифры). Причина, по которой не объединены в
один тип логические операции and и or заключается в том, что эти
операции имеют различный приоритет. 

Пример цепочки: for i3:=10 to n do x=y-z+70 ;

### Классификация грамматики
Грамматика G[(For)] является контекстно-свободной (КС-грамматикой), так как все её правила имеют вид:

A → α,

где A — нетерминал, а α — цепочка терминалов и/или нетерминалов.

### Язык
1. Алфавит (Σ)
Терминальные символы (токены):

Ключевые слова: for, to, do, and, or

Операторы:

:= (присваивание в цикле)

as (оператор = в грамматике)

ao (+ или -)

Идентификаторы:

id (буквы и цифры, напр. i, x1)

var (только буквы, напр. a, count)

Константы:

const (числа, напр. 10, -5)

Конечный символ: ;

2. Нетерминальные символы (N)
(For) (начальный символ)

(Operand) (операнд: переменная или константа)

(Stmt) (оператор присваивания)

(ArithExpr) (арифметическое выражение)

3. Правила вывода (P)
(For) → for id := (Operand) to (Operand) do (Stmt) ;

(Operand) → var | const

(Stmt) → var as (ArithExpr)

(ArithExpr) → (Operand) {ao (Operand)}

4. Допустимые цепочки
Язык L(G) состоит из всех строк вида:

for id := (Operand) to (Operand) do (Stmt) ;

### Тестовые примеры
![изображение](https://github.com/user-attachments/assets/8b73bbd7-488e-48f7-9633-3433eeb509fc)

![изображение](https://github.com/user-attachments/assets/01928cb3-4445-4060-82f9-963a53a92a8e)






