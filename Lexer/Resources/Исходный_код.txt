Parser.cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text.RegularExpressions;
using System.Windows.Forms;

namespace Lexer
{
    public class RecordParser
    {
        private static readonly HashSet<string> Keywords = new HashSet<string> { "type", "record", "end", "real", "integer", "string", "boolean", "char" };

        private enum TokenType { Keyword, Identifier, Symbol }

        private class Token
        {
            public TokenType Type;
            public string Value;
            public int Position;

            public Token(TokenType type, string value, int position)
            {
                Type = type;
                Value = value;
                Position = position;
            }

            public override string ToString() => $"{Type}: {Value} (at {Position})";
        }

        public List<(string message, int position, int length)> ParseRecord(string input, RichTextBox richTextBox)
        {
            var (tokens, lexErrors) = Tokenize(input, richTextBox);
            var errors = new List<(string message, int position, int length)>();
            errors.AddRange(lexErrors);

            int i = 0;

            void Expect(string expected, string context)
            {
                if (i >= tokens.Count)
                {
                    errors.Add(($"Ожидалось '{expected}' {context}, найдено 'EOF'", input.Length, 1));
                    return;
                }

                if (tokens[i].Value != expected)
                {
                    errors.Add(($"Ожидалось '{expected}' {context}, найдено '{tokens[i].Value}'", tokens[i].Position, tokens[i].Value.Length));
                }

                i++;
            }

            bool CheckIdentifier(string context)
            {
                if (i >= tokens.Count)
                {
                    errors.Add(($"Ожидался идентификатор {context}, найдено 'EOF'", input.Length, 1));
                    return false;
                }

                if (tokens[i].Type != TokenType.Identifier)
                {
                    errors.Add(($"Ожидался идентификатор {context}, найдено '{tokens[i].Value}'", tokens[i].Position, tokens[i].Value.Length));
                    i++;
                    return false;
                }

                i++;
                return true;
            }

            try
            {
                Expect("type", "в начале объявления");
                CheckIdentifier("после 'type'");

                if (i >= tokens.Count || tokens[i].Value != "=")
                {
                    int pos = i < tokens.Count ? tokens[i].Position : input.Length;
                    errors.Add(($"Ожидалось '=' после имени типа, найдено '{(i < tokens.Count ? tokens[i].Value : "EOF")}'", pos, 1));
                    tokens.Insert(i, new Token(TokenType.Symbol, "=", pos));
                }
                i++;

                if (i >= tokens.Count || tokens[i].Value != "record")
                {
                    int pos = i < tokens.Count ? tokens[i].Position : input.Length;
                    errors.Add(($"Ожидалось 'record' после '=', найдено '{(i < tokens.Count ? tokens[i].Value : "EOF")}'", pos, 1));
                    tokens.Insert(i, new Token(TokenType.Keyword, "record", pos));
                    i++;
                }
                i++;

                var validTypes = new HashSet<string> { "integer", "real", "char", "boolean", "string" };

                while (i < tokens.Count && tokens[i].Value != "end")
                {
                    var fieldNames = new List<string>();
                    bool awaitingComma = false;
                    bool colonExpected = false;

                    // Сбор имён полей
                    while (i < tokens.Count)
                    {
                        if (tokens[i].Value == ":")
                        {
                            colonExpected = true;
                            break;
                        }

                        // Если встретили тип или конец записи - выходим
                        if ((tokens[i].Type == TokenType.Keyword && validTypes.Contains(tokens[i].Value.ToLower())) ||
                            tokens[i].Value == "end" || tokens[i].Value == ";")
                        {
                            break;
                        }

                        if (tokens[i].Type == TokenType.Identifier && !Keywords.Contains(tokens[i].Value))
                        {
                            if (awaitingComma)
                            {
                                errors.Add(($"Пропущена запятая между именами полей перед '{tokens[i].Value}'",
                                            tokens[i].Position, tokens[i].Value.Length));
                            }

                            fieldNames.Add(tokens[i].Value);
                            i++;
                            awaitingComma = true;
                        }
                        else if (tokens[i].Value == ",")
                        {
                            if (!awaitingComma)
                            {
                                errors.Add(("Запятая без идентификатора перед ней", tokens[i].Position, 1));
                            }
                            i++;
                            awaitingComma = false;
                        }
                        else
                        {
                            // Неизвестный токен - предполагаем, что это начало типа
                            break;
                        }
                    }
                    // Обработка двоеточия
                    if (!colonExpected)
                    {
                        if (i < tokens.Count && tokens[i].Value != ":" && fieldNames.Count > 0)
                        {
                            errors.Add(("Ожидалось ':' после списка полей", tokens[i].Position, 1));
                            tokens.Insert(i, new Token(TokenType.Symbol, ":", tokens[i].Position));
                        }
                    }

                    if (i < tokens.Count && tokens[i].Value == ":")
                    {
                        i++; // пропустить двоеточие
                    }

                    // Проверка типа
                    if (i >= tokens.Count || tokens[i].Value == "end" || tokens[i].Value == ";")
                    {
                        int pos = i < tokens.Count ? tokens[i].Position : input.Length;
                        errors.Add(("Ожидался тип поля", pos, 1));
                        tokens.Insert(i, new Token(TokenType.Keyword, "integer", pos));
                        i++;
                    }
                    else
                    {
                        string typeName = tokens[i].Value;
                        if (!validTypes.Contains(typeName.ToLower()))
                        {
                            errors.Add(($"Недопустимый тип поля: '{typeName}'", tokens[i].Position, typeName.Length));
                        }
                        i++;
                    }

                    // Завершение поля
                    if (i < tokens.Count && tokens[i].Value == ";")
                    {
                        i++;
                    }
                    else if (i < tokens.Count && tokens[i].Value == "end")
                    {
                        // Если встретили 'end' без точки с запятой - это нормально
                        continue;
                    }
                    else if (fieldNames.Count > 0)
                    {
                        // Если нет ни ';' ни 'end' - ожидаем 'end'
                        break;
                    }
                }

                // Проверка закрытия записи
                if (i >= tokens.Count || tokens[i].Value != "end")
                {
                    int pos = i < tokens.Count ? tokens[i].Position : input.Length;
                    errors.Add(("Ожидалось 'end' в конце объявления", pos, 3));

                    // Восстанавливаем: добавляем "end" токен
                    tokens.Insert(i, new Token(TokenType.Keyword, "end", pos));
                }
                else
                {
                    i++; // если "end" был — просто идём дальше
                }


                // Проверка на ; после end
                if (i < tokens.Count && tokens[i].Value == ";")
                {
                    i++;
                }
                else if (i < tokens.Count)
                {
                    errors.Add(("Ожидалась ';' после 'end'", tokens[i].Position, 1));
                }
                else
                {
                    // Конец ввода — но точка с запятой всё равно обязательна
                    errors.Add(("Ожидалась ';' после 'end'", input.Length, 1));
                }

            }
            catch (Exception ex)
            {
                errors.Add(($"Ошибка при разборе: {ex.Message}", input.Length, 1));
            }

            return errors;
        }

        private (List<Token> tokens, List<(string message, int position, int length)> errors) Tokenize(string input, RichTextBox richTextBox)
        {
            var tokens = new List<Token>();
            var lexErrors = new List<(string message, int position, int length)>();

            var cleanedInput = Regex.Replace(input, @"[^a-zA-Z0-9_:\s,;=\n]", m =>
            {
                lexErrors.Add(($"Недопустимый символ '{m.Value}'", m.Index, 1));
                HighlightError(richTextBox, m.Index, 1);
                return "";
            });

            var pattern = @"\w+|[:,;=]";
            var matches = Regex.Matches(cleanedInput, pattern);

            foreach (Match match in matches)
            {
                string val = match.Value;
                int pos = match.Index;

                if (Regex.IsMatch(val, @"^[a-zA-Z_]\w*$"))
                {
                    if (Keywords.Contains(val))
                        tokens.Add(new Token(TokenType.Keyword, val, pos));
                    else
                        tokens.Add(new Token(TokenType.Identifier, val, pos));
                }
                else if (Regex.IsMatch(val, @"^[:,;=]$"))
                {
                    tokens.Add(new Token(TokenType.Symbol, val, pos));
                }
            }

            return (tokens, lexErrors);
        }

        private void HighlightError(RichTextBox richTextBox, int start, int length)
        {
            int originalSelectionStart = richTextBox.SelectionStart;
            int originalSelectionLength = richTextBox.SelectionLength;

            richTextBox.Select(start, length);
            richTextBox.SelectionBackColor = Color.Plum;

            richTextBox.Select(originalSelectionStart, originalSelectionLength);
        }
    }
}
Form1.cs
private void Analyze()
{
    if (tabControl1.SelectedTab == null || dataGridView1 == null) return;

    var splitContainer = tabControl1.SelectedTab.Controls.OfType<SplitContainer>().FirstOrDefault();
    if (splitContainer == null) return;

    var editorRichTextBox = splitContainer.Panel2.Controls.OfType<RichTextBox>().FirstOrDefault();
    if (editorRichTextBox == null) return;

    SetStatus("Выполнение синтаксического анализа...");
    try
    {
        string inputText = editorRichTextBox.Text;
        var parser = new RecordParser();
        var errors = parser.ParseRecord(inputText, editorRichTextBox);

        dataGridView1.Invoke((MethodInvoker)delegate
        {
            dataGridView1.Rows.Clear();

            if (errors.Count == 0)
            {
                MessageBox.Show("Анализ завершен успешно. Ошибок не найдено.", "Результат анализа",
                                MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            else
            {
                foreach (var (message, position, length) in errors)
                {
                    (int line, int col) = GetLineAndColumn(inputText, position);
                    int endCol = col + length;

                    dataGridView1.Rows.Add(
                        message,
                        (line + 1).ToString(),           // Строка
                        $"{col + 1}-{endCol}"           // Позиция
                    );
                }

                MessageBox.Show($"Найдено {errors.Count} ошибок.", "Результат анализа",
                                MessageBoxButtons.OK, MessageBoxIcon.Warning);
            }

            SetStatus("Синтаксический анализ завершен");
        });
    }
    catch (Exception ex)
    {
        MessageBox.Show($"Ошибка при анализе: {ex.Message}", "Ошибка",
                        MessageBoxButtons.OK, MessageBoxIcon.Error);
    }
}


private (int line, int column) GetLineAndColumn(string text, int position)
{
    int line = 0, column = 0, index = 0;
    var lines = text.Split('\n');

    foreach (var ln in lines)
    {
        if (position <= index + ln.Length)
        {
            column = position - index;
            break;
        }
        index += ln.Length + 1; // +1 за '\n'
        line++;
    }

    return (line, column);
}


private void toolStripButton9_Click(object sender, EventArgs e)
{
    Analyze();
}

private void пускToolStripMenuItem_Click(object sender, EventArgs e)
{
    Analyze();
}
About.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Lexer
{
    public partial class About: Form
    {
        public About()
        {
            InitializeComponent();

            Text = "О программе";
            label1.Text = "Версия 0.0.1";
            label2.Text = "Автор: Качигина Валерия Алексеевна";
            label3.Text = "Языковой процессор";
        }
    }
}
GR.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Lexer
{
    public partial class GR: Form
    {
        public GR()
        {
            InitializeComponent();


            Text = "Грамматика";
            webBrowser3.DocumentText = Properties.Resources.Грамматика;
        }
    }
}
Help.cs
using Lexer.Properties;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Lexer
{
    public partial class Help : Form
    {
        public Help()
        {
            InitializeComponent();

            Text = "Справка";
            webBrowser1.DocumentText = Properties.Resources.Справка;

        }
    }
}
IK.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Lexer
{
    public partial class IK: Form
    {
        public IK()
        {
            InitializeComponent();

            Text = "Исходный код";
            webBrowser8.DocumentText = Properties.Resources.Исходный_код;
        }
    }
}
KL.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Lexer
{
    public partial class KL: Form
    {
        public KL()
        {
            InitializeComponent();

            Text = "Классификация";
            webBrowser4.DocumentText = Properties.Resources.Классификация;
        }
    }
}
MetA.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Lexer
{
    public partial class MetA : Form
    {
        public MetA()
        {
            InitializeComponent();
            Text = "Методы анализа";

            // Получаем HTML из ресурсов
            string htmlTemplate = Properties.Resources.Методы_анализа;

            // Получаем изображение из ресурсов и превращаем в base64
            using (MemoryStream ms = new MemoryStream())
            {
                Properties.Resources.ТфякСхема.Save(ms, System.Drawing.Imaging.ImageFormat.Png);
                string base64Image = Convert.ToBase64String(ms.ToArray());

                // Вставляем в HTML вместо имени файла
                string htmlWithImage = htmlTemplate.Replace("ТфякСхема.png", $"data:image/png;base64,{base64Image}");

                // Загружаем в WebBrowser
                webBrowser5.DocumentText = htmlWithImage;
            }
        }
    }

}
SL.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Lexer
{
    public partial class SL: Form
    {
        public SL()
        {
            InitializeComponent();

            Text = "Список литературы";
            webBrowser7.DocumentText = Properties.Resources.Список_литературы;
        }
    }
}
TP.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Lexer
{
    public partial class TP : Form
    {
        public TP()
        {
            InitializeComponent();
            Text = "Тестовый пример";

            // Загружаем HTML-шаблон из ресурсов
            string html = Properties.Resources.Тестовый_пример;

            // Подставляем изображения
            html = InsertImageIntoHtml(html, "test1.png", Properties.Resources.test1);
            html = InsertImageIntoHtml(html, "test2.png", Properties.Resources.test2);
            html = InsertImageIntoHtml(html, "test3.png", Properties.Resources.test3);

            // Отображаем в WebBrowser
            webBrowser6.DocumentText = html;
        }

        private string InsertImageIntoHtml(string html, string placeholder, Image image)
        {
            using (MemoryStream ms = new MemoryStream())
            {
                image.Save(ms, System.Drawing.Imaging.ImageFormat.Png);
                string base64 = Convert.ToBase64String(ms.ToArray());
                string dataUri = $"data:image/png;base64,{base64}";
                return html.Replace(placeholder, dataUri);
            }
        }
    }

}
ПЗ.cs
using Lexer.Properties;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Lexer
{
    public partial class ПЗ: Form
    {
        public ПЗ()
        {
            InitializeComponent();

            Text = "Постановка задачи";
            webBrowser2.DocumentText = Properties.Resources.Постановка_задачи;
        }
    }
}
